/**
 * Binary Wrapper Module
 * 
 * Creates a "shadow" git binary that intercepts dangerous commands
 * (reset, clean, branch -D) that don't have native git hooks.
 * 
 * This is the ONLY reliable way to protect against agents that
 * call /usr/bin/git directly, bypassing git aliases.
 */

import fs from 'fs';
import path from 'path';
import { execSync } from 'child_process';
import chalk from 'chalk';
import { ensureDir } from './git';

/**
 * Find the real git binary path (not our wrapper)
 */
export function findRealGitPath(): string {
  try {
    // Try common locations first
    const commonPaths = [
      '/usr/bin/git',
      '/usr/local/bin/git',
      '/opt/homebrew/bin/git',
    ];

    for (const gitPath of commonPaths) {
      if (fs.existsSync(gitPath)) {
        return gitPath;
      }
    }

    // Fall back to which git, filtering out our wrapper
    const whichOutput = execSync('which -a git 2>/dev/null || true', { encoding: 'utf-8' });
    const gitPaths = whichOutput.trim().split('\n').filter(p => 
      p && !p.includes('.saferun/bin')
    );

    if (gitPaths.length > 0) {
      return gitPaths[0];
    }

    return '/usr/bin/git';
  } catch {
    return '/usr/bin/git';
  }
}

/**
 * Generate the shell script content for the git wrapper
 */
export function generateWrapperScript(realGitPath: string): string {
  return `#!/bin/sh
# ═══════════════════════════════════════════════════════════════════════════════
# SafeRun Git Binary Wrapper
# 
# This script intercepts git commands that don't have native hooks
# (reset, clean, branch -D, checkout, stash drop) and routes them through SafeRun.
#
# IMPORTANT: For this to work, either:
#   1. Run: saferun shell-init --auto (adds smart git function to ~/.zshrc)
#   2. Or manually: export PATH="./.saferun/bin:\$PATH"
#
# Generated by: saferun init
# Real git path: ${realGitPath}
# ═══════════════════════════════════════════════════════════════════════════════

REAL_GIT="${realGitPath}"
COMMAND="\$1"

# Check if saferun CLI is available
if ! command -v saferun >/dev/null 2>&1; then
    # SafeRun not installed, pass through to real git
    exec "\$REAL_GIT" "\$@"
fi

# Intercept dangerous commands without native hooks
case "\$COMMAND" in
    reset)
        # git reset [--soft|--mixed|--hard] - especially dangerous with --hard
        saferun hook git-reset "\$@"
        EXIT_CODE=\$?
        if [ \$EXIT_CODE -ne 0 ]; then
            exit \$EXIT_CODE
        fi
        # SafeRun approved, execute real command
        exec "\$REAL_GIT" "\$@"
        ;;
    
    clean)
        # git clean - removes untracked files permanently
        saferun hook git-clean "\$@"
        EXIT_CODE=\$?
        if [ \$EXIT_CODE -ne 0 ]; then
            exit \$EXIT_CODE
        fi
        exec "\$REAL_GIT" "\$@"
        ;;
    
    branch)
        # git branch -D / -d - deletes branches
        # Only intercept if -D or -d flag is present
        case "\$*" in
            *-D*|*-d*|*--delete*)
                saferun hook git-branch "\$@"
                EXIT_CODE=\$?
                if [ \$EXIT_CODE -ne 0 ]; then
                    exit \$EXIT_CODE
                fi
                ;;
        esac
        exec "\$REAL_GIT" "\$@"
        ;;
    
    checkout)
        # git checkout -- <file> can discard changes
        case "\$*" in
            *" -- "*)
                saferun hook git-checkout "\$@"
                EXIT_CODE=\$?
                if [ \$EXIT_CODE -ne 0 ]; then
                    exit \$EXIT_CODE
                fi
                ;;
        esac
        exec "\$REAL_GIT" "\$@"
        ;;
    
    stash)
        # git stash drop/clear - can lose stashed work
        case "\$*" in
            *drop*|*clear*)
                saferun hook git-stash "\$@"
                EXIT_CODE=\$?
                if [ \$EXIT_CODE -ne 0 ]; then
                    exit \$EXIT_CODE
                fi
                ;;
        esac
        exec "\$REAL_GIT" "\$@"
        ;;
    
    *)
        # All other commands pass through directly
        # (commit, push, etc. are handled by native git hooks)
        exec "\$REAL_GIT" "\$@"
        ;;
esac
`;
}

/**
 * Install the binary wrapper in the repository
 */
export async function installBinaryWrapper(repoRoot: string): Promise<{
  installed: boolean;
  wrapperPath: string;
  realGitPath: string;
}> {
  const binDir = path.join(repoRoot, '.saferun', 'bin');
  const wrapperPath = path.join(binDir, 'git');
  const realGitPath = findRealGitPath();

  // Create .saferun/bin directory
  await ensureDir(binDir);

  // Generate and write the wrapper script
  const scriptContent = generateWrapperScript(realGitPath);
  await fs.promises.writeFile(wrapperPath, scriptContent, { mode: 0o755 });

  // Ensure it's executable
  await fs.promises.chmod(wrapperPath, 0o755);

  return {
    installed: true,
    wrapperPath,
    realGitPath,
  };
}

/**
 * Check if the binary wrapper is in PATH and active
 */
export async function checkBinaryWrapperInPath(repoRoot: string): Promise<{
  inPath: boolean;
  currentGit: string;
  expectedPath: string;
}> {
  const expectedPath = path.join(repoRoot, '.saferun', 'bin', 'git');
  
  try {
    const whichGit = execSync('which git 2>/dev/null', { 
      encoding: 'utf-8',
      cwd: repoRoot,
    }).trim();

    // Check if the resolved git is our wrapper
    const inPath = whichGit.includes('.saferun/bin/git') || 
                   whichGit === expectedPath ||
                   path.resolve(repoRoot, whichGit) === expectedPath;

    return {
      inPath,
      currentGit: whichGit,
      expectedPath,
    };
  } catch {
    return {
      inPath: false,
      currentGit: 'unknown',
      expectedPath,
    };
  }
}

/**
 * Check if wrapper file exists in the repo
 */
export function wrapperExists(repoRoot: string): boolean {
  const wrapperPath = path.join(repoRoot, '.saferun', 'bin', 'git');
  return fs.existsSync(wrapperPath);
}

/**
 * Get PATH export command for user
 */
export function getPathExportCommand(repoRoot: string): string {
  return 'export PATH="./.saferun/bin:$PATH"';
}

/**
 * Print setup instructions for the binary wrapper
 */
export function printBinaryWrapperInstructions(repoRoot: string): void {
  console.log(chalk.yellow('\n⚠️  IMPORTANT: Agent Protection Setup\n'));
  console.log(chalk.white('To protect against agents that bypass git aliases, run:'));
  console.log('');
  console.log(chalk.cyan('  saferun shell-init --auto'));
  console.log('');
  console.log(chalk.gray('This adds a smart git() function to ~/.zshrc that automatically'));
  console.log(chalk.gray('uses the SafeRun wrapper in any protected project.\n'));
  
  console.log(chalk.white('Alternative (per-session):'));
  console.log(chalk.cyan(`  ${getPathExportCommand(repoRoot)}`));
}
